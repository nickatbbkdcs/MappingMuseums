#!/usr/bin/env python

##
# @file
# This program reads the headers in the data sheet as a csv file with DOLLAR as separator and all text fields quoted.
# It produces  a graphMl file that represents the ontology needed to map the columns in the data sheet to
# RDF classes and predicates.
#
# A typical call could look like this: 
#  python ${XBIN}/makeGMLNodesFromSheet.py ${MLNAMES} ${FNAME_GEONAMES} ${GNAME} ${GNODESNAME}
#
# arg1 namestemplate : graphmlNames.template : A file that has node and edge templates in graphMl.
# The template contains macros ${MACRO} that will be
# called to generate the actual graphMl nodes in the output file. E.g.
# <node id="${nodeid}">
# ....  
# </node>
# nodeid is a python method in this file which will be called when the line with the macro is processed.
# This file is a template for the LIST datatype and is only used if such a datatype is found in the sheet.
# Called from generateobjectnamenodes.
#
# arg2 The data sheet from which the graphml is generated. The sheet needs to have the headers specified
# as shown in the documentation ETLDOC
#
# arg3 graphml.template : A file that has node and edge templates in graphMl
# that represents data properties in rdf.
#
# arg4 graphmlNodes.template :A file that has node and edge templates in graphMl
# that represents object properties in rdf.
#
# General outline:
#
#   Read data sheet (arg2)
#   Read data property template (arg3)
#   Read object property template (arg4)
#
#   For each column in data sheet
#       process line in data property templates
#       if macro is found in template evaluate the macro and insert text as replacement
#       in output stream
#   Repeat for object property template
#
#
#   A symbol table is used to hold values like current node id between macro calls.
#   A macro can switch on or off printing as a method of supressing output.
#   A number of central variables are GLOBAL to the processing as it simplified the
#   programming.
#   Nodes and edges has a starting number. This is dependent on the whether you have other
#   nodes in the ontology preceding the nodes that will be generated by the program. In this
#   case there are 25 nodes preceding so we need to start from this number. This should be a
#   parameter to the program in next version.
#
#   A small set of node and edge creation methods are used for creating method patterns.
#   These are used by the pattern "createTemporalProperty" which is easier to implement in this
#   way compared to using macros.
#   Notice the base node which is n0 = Musuem class
#
#  More details.
#  $$Author$:Nick Larsson, Researcher, Dep. of Computer Science and Information Systems at Birkbeck University, London, England, email:nick@dcs.bbk.ac.uk, License:GNU GPLv3

version = "1.7"
version_info = (1,7,0,"rc-1")
__revision__ = "$Rev: 66 $"




from bs4 import BeautifulSoup
import pprint
import copy
import sys


UNQUOTEVALUES=True
sequenceorder=0 # Order for temporal nodes
SEQUENCE_ORDER="sequenceorder"
PARENT_NODE="parentnode"
BASE_NODE="basenode" # The node from which all originates = n0 Zero (Museum class)
DATACOL="datacolumnforlists"
PROCESSINGCOLUMN="PROCESSINGCOLUMN" # Current column to process


#-----------------------------------------------------------------------------------
## Purpose: Processes each line in the template and evaluates the macros.
#
# Arguments:
#  @header The header from the sheet
#  @line   The line in the template
#  @indatamodel The whole sheet  
#  @symboltable The symbol table to store/read values from
#
def processLine(header,
		line,
		indatamodel,
		symboltable):
    fm=1
    newline=""
    linecopy=copy.deepcopy(line)
    while (fm > 0):
        fm=linecopy.find("${")
        if (fm > -1):
            defstart=fm+2
            ll=len(linecopy)
            var=""
            while (defstart < ll and linecopy[defstart] !=  "}"):
                var=var+linecopy[defstart]
                defstart+=1
            estring=evaluatemacro(var,indatamodel,symboltable)
            defstart+=1
            newline=newline+str(linecopy[0:fm])+str(estring)
            linecopy=linecopy[defstart:ll]
    newline=newline+linecopy
    return newline

#-----------------------------------------------------------------------------------
## Purpose: Evaluates a macro by calling a global method in this file with the same name
#
# Arguments:
#  @var The name of the macro
#  @indatamodel The sheet
#  @symboltable The symbol table to store/read values from
def evaluatemacro(var,indatamodel,symboltable):

    is_valid_number=True
    try:
        int(var)
    except ValueError:
        is_valid_number = False
    assign=var.find("=")
    if (is_valid_number == True):
        # return row[number]
        noop=1
	if (UNQUOTEVALUES):
		unquotedvalue=indatamodel[int(var)].replace('"','')
		return unquotedvalue 
	else:
		return indatamodel[int(var)]
    else:
        #just eval
	if(assign > 0):
		syms=var.split("=")
		var=syms[1]
		leftside=syms[0]
        lparen=var.find("(")
	if (lparen > -1):
		rparen=var.find(")")
		param=var[lparen+1:rparen]
		funcname=var[0:lparen]
	        returnval=globals()[funcname](param)
		if(assign > 0):
			symboltable[leftside]=returnval
		return returnval
	else:
		if (var in symboltable):
			return symboltable[var]
		else:
			returnval=globals()[var]()
			if(assign > 0):
				symboltable[leftside]=returnval
				
		return returnval
		
    return ""


#-----------------------------------------------------------------------------------
## Purpose: Processes one template line by line
#
# Arguments:
#  @header The header
#  @template The template
#  @indatamodel The sheet
#  @SYMBOLTABLE The symbol table to store/read values from
def processTemplate(header,template,indatamodel,SYMBOLTABLE):
    global  datamodel
    savedatamodel=datamodel
    datamodel=indatamodel
    i = 1
    while i < len(template):
        newline=processLine(header,
                            template[i],
                            indatamodel,
                            SYMBOLTABLE)
        if (PRINT_LINE):
            print newline
        i += 1
    datamodel=savedatamodel
    return


#-----------------------------------------------------------------------------------
## Purpose: Removes unwanted characters from argument.
# Arguments:
#  @name The string to clean
def cleanName(name):
    name=name.replace(" ","_")
    return ''.join([i for i in name if (i.isalpha() or i == "_")])


#-----------------------------------------------------------------------------------

if __name__ == '__main__':
    """ Run Process from the command line. """


NODEID=25
EDGEID=25
TARGETID=25
COL=0
SEPARATOR="$"
PRINT_LINE=True
PREFIX_WITH_COLON="bbkmm:"
PREFIX="bbkmm"
RANGE="range:"
HIER="hier:"
URI="uri:"
XSD="xsd:"
IS="Is"
DEF="def"
HAS="has"
DEFRANGE="defRange"
DEFCLASS="defClass"
DATATYPEDICT={}
HIER_TYPE="HierType"
LIST_TYPE="ListType"
RANGE_TYPE="RangeType"
URITYPE="URIType"

#-----------------------------------------------------------------------------------
#                                   For the objectproperties
#-----------------------------------------------------------------------------------
## Purpose:This function is called in the graphmlNodes template and determines if a node is an
#  object node starting with prefix. All other nodes get supressed via the PRINT_LINE variable.
def objectnodeid():
    global NODEID
    global PRINT_LINE
    global COL
    actualdata=valuedatamodel[COL].replace('"','')
    if (actualdata[0:len(PREFIX_WITH_COLON)] == PREFIX_WITH_COLON ):
        PRINT_LINE=True
    else:
        PRINT_LINE=False
        return "#1ID bbkmm !! objectnodeid"
        
    NODEID=NODEID+1
    return str(NODEID)

#-----------------------------------------------------------------------------------
## Purpose: Returns the type as declared in the sheet header.
def objecttype():
    global COL
    actualdata=valuedatamodel[COL].replace('"','')
    return actualdata

#-----------------------------------------------------------------------------------
## Purpose:Returns the abstraction (def) appended to the type.
def objectpredicate():
    global COL
    predicate=DEF+str(datamodel[COL].replace('"',''))
    return predicate

#-----------------------------------------------------------------------------------
## Purpose: Increments the current edge id.
def objectedgeid():
    global EDGEID
    global PRINT_LINE

    if (PRINT_LINE == False):
        return "#2ID bbkmm !! object edgeid"

    EDGEID=EDGEID+1
    return str(EDGEID)
#-----------------------------------------------------------------------------------
## Purpose: Generates graphMl for the hierarchy abstract type 

def generatehierclasses():
    global COL
    global NODEID
    global SYMBOLTABLE
    global PRINT_LINE

    PRINT_LINE=True
    propertyname=str(datamodel[COL].replace('"',''))
    actualdata=valuedatamodel[COL].replace('"','')
    if (actualdata[0:len(HIER)] != HIER):
	return ""
    # First create a class node with the prop name
    NODEID=NODEID+1
    classnode=NODEID
    print createObjectNode(classnode,PREFIX_WITH_COLON+DEFCLASS+propertyname,col()+","+vis())

    # Create a hasProperty object property from the museum
    hasclassedge=edgeid()
    print createObjectPropertyEdge(hasclassedge,SYMBOLTABLE[BASE_NODE],classnode,"has"+propertyname)

    # Send this new class node as parent to have all its subclasses mapped
    createHierarchySubclasses(classnode,
			      propertyname
			      )

    return


#-----------------------------------------------------------------------------------
## Purpose:Generates graphMl for the abstract RangeType

def generatetemporalrangenodes():
    global COL
    global NODEID
    global SYMBOLTABLE
    global PRINT_LINE


    actualdata=valuedatamodel[COL].replace('"','')
    if (actualdata[0:len(RANGE)] != RANGE):
	return ""
    rtype=actualdata[len(RANGE):]
    PRINT_LINE=True
    createValueRangeProperty(SYMBOLTABLE[BASE_NODE],
			     str(datamodel[COL].replace('"','')),
			     rtype
			   )

    return

#-----------------------------------------------------------------------------------
## Purpose: Creates a URI node attached to the base node representing an individual

def generateurireferences():
    global COL
    global NODEID
    global SYMBOLTABLE
    global PRINT_LINE


    actualdata=valuedatamodel[COL].replace('"','')
    if (actualdata[0:len(URI)] != URI):
	return ""
    rtype=actualdata[len(URI):]
    PRINT_LINE=True
    createURIreferenceObjectProperty(SYMBOLTABLE[BASE_NODE],
				     str(datamodel[COL].replace('"','')),
				     rtype
				     )

    return


#-----------------------------------------------------------------------------------
## Purpose: Returns the data for the column.

def datacolumn():
    global SYMBOLTABLE
    return SYMBOLTABLE[DATACOL]


#-----------------------------------------------------------------------------------
## Purpose:Creates all names in a LIST_TYPE abstraction using the file given as arg1
# to the program.

def generateobjectnamenodes():
    global COL
    global NODEID
    global SYMBOLTABLE
    
    ## We only want to do this for URIs, not dataproperties
    actualdata=valuedatamodel[COL].replace('"','')
    if (actualdata[0:len(PREFIX_WITH_COLON)] != PREFIX_WITH_COLON):
        return ""
    
    ###  Go through all rows in COL and generate list of values
    valuesmap={}
    cl=len(content)
    startrow=5
    while (startrow < cl ):
        row=content[startrow].split(SEPARATOR)
        
        valuesmap[row[COL]]=row[COL]
        startrow=startrow+1

    namestemplate=str(sys.argv[1])

    with open(namestemplate) as f:
	nametemplate = f.readlines()
    f.close()

    ###  Create input for processtemplate
    # Turn valuesmap into list
    valueslist=[]
    for key, val in valuesmap.iteritems():
        if (len(key) > 0):
            valueslist.append(key)

	    
    ###  Call processtemplate for each value
    j = 0
    savecol=COL
    ## This is the parent node we need to point to for the edge
    SYMBOLTABLE[PARENT_NODE]=NODEID
    SYMBOLTABLE[DATACOL]=COL
    
    while j < len(valueslist):
        COL=j
        processTemplate(header,nametemplate,valueslist,SYMBOLTABLE)
        j += 1
    COL=savecol
    ###  
    ### Return template for printing
    return ""

#-----------------------------------------------------------------------------------
## Purpose: Returns the node id of the current nodes parent.

def parentnodenumber():
    global SYMBOLTABLE
    
    return     str(SYMBOLTABLE[PARENT_NODE])

#-----------------------------------------------------------------------------------
#                             For the name properties
#-----------------------------------------------------------------------------------
## Purpose: Returns the string used as a name from the sheet.

def nameinstance():
    global COL
    global NODEID
    global SYMBOLTABLE
    
    return datamodel[COL]


#-----------------------------------------------------------------------------------
## Purpose: Returns the string used as predicate

def namedproperty():
    global COL
    global NODEID
    global SYMBOLTABLE

    return "hasNamedInstance"+str(cleanName(datamodel[COL].replace('"','')))


#-----------------------------------------------------------------------------------
#                                 For the dataproperties
#-----------------------------------------------------------------------------------
## Purpose: Increments the current nodeid and checks that the type is correct

def nodeid():
    global PRINT_LINE
    global NODEID
    global SYMBOLTABLE
    global PROCESSINGCOLUMN
    
    actualdata=valuedatamodel[SYMBOLTABLE[PROCESSINGCOLUMN]].replace('"','')
    if (actualdata[0:len(XSD)] == XSD or
	actualdata[0:len(RANGE)] == RANGE or
	actualdata[0:len(HIER)] == HIER or
	actualdata[0:len(PREFIX_WITH_COLON)] == PREFIX_WITH_COLON):
        PRINT_LINE=True
    else:
        PRINT_LINE=False
        return "#3ID bbkmm !! nodeid"


    
    NODEID=NODEID+1
    return str(NODEID)

#-----------------------------------------------------------------------------------
## Purpose:Reports the current node id without incrementing it.

def nodeidnoupdate():
    global NODEID


    return str(NODEID)

#-----------------------------------------------------------------------------------
## Purpose :Increments and returns the current target id.

def targetid():
    global TARGETID

    global PRINT_LINE
    if (PRINT_LINE == False):
        return "#4ID bbkmm !! targetid"

    TARGETID=TARGETID+1
    return str(TARGETID)

#-----------------------------------------------------------------------------------
## Purpose:Increments and returns the current edge id.
#

def edgeid():
    global EDGEID
    global PRINT_LINE
    if (PRINT_LINE == False):
        return "#5ID bbkmm !! edgeid"

    EDGEID=EDGEID+1
    return str(EDGEID)


#-----------------------------------------------------------------------------------
## Purpose: Returns the datatype for the column

def datatype():
    global COL
    actualdata=valuedatamodel[COL]
    return actualdata.replace('"','').replace(RANGE,XSD)

#-----------------------------------------------------------------------------------
## Purpose:Returns the predicate name for the column
# 

def predicate():
    global COL
    return "has"+str(datamodel[COL].replace('"',''))

#-----------------------------------------------------------------------------------
#                                    Shared
#-----------------------------------------------------------------------------------
## Purpose: Returns current column
# 

def col():
    global COL
    return str(COL)

#-----------------------------------------------------------------------------------
## Purpose: Returns the visibility of a column (Not used)


def vis():
    global COL
    return str(visdatamodel[COL])

#-----------------------------------------------------------------------------------
#                                    Node and edge creation
#-----------------------------------------------------------------------------------
## Purpose: Creates a graphML datanode with id data and name inserted.
# Arguments:
#  @id The id of the node
#  @name The name of the node
#  @data The data to be inserted in the data field.

def createDataNode(id,name,data):
    nodedef="""    <node id='"""+str(id)+"""'>
      <data key="d4"/>
      <data key="d6">"""+str(data)+"""</data>
      <data key="d7">
        <y:ShapeNode>
          <y:Geometry height="43.0" width="93.28125" x="87.04674330109151" y="1098.2026573938933"/>
          <y:Fill color="#CCFFCC" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Dialog" fontSize="16" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="22.625" modelName="internal" modelPosition="c" textColor="#000000" visible="true" width="83.28125" x="5.0" y="10.1875">"""+name+"""</y:NodeLabel>
          <y:Shape type="parallelogram"/>
        </y:ShapeNode>
      </data>
    </node>"""

    return  nodedef


#-----------------------------------------------------------------------------------
## Purpose: Creates a graphML objectnode with id data and name inserted.
# Arguments:
#  @id The id of the node
#  @name The name of the node
#  @data The data to be inserted in the data field.
def createObjectNode(id,name,data):
    nodedef="""    <node id='"""+str(id)+"""'>
      <data key="d4"/>
      <data key="d6">"""+str(data)+"""</data>
      <data key="d7">
        <y:ShapeNode>
          <y:Geometry height="44.0" width="186.4296875" x="742.6735182434335" y="264.30975422322564"/>
          <y:Fill color="#FFFF00" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Dialog" fontSize="16" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="22.625" modelName="internal" modelPosition="c" textColor="#000000" visible="true" width="176.4296875" x="5.0" y="10.6875">"""+name+"""</y:NodeLabel>
          <y:Shape type="roundrectangle"/>
        </y:ShapeNode>
      </data>
        </node>"""

    return  nodedef


#-----------------------------------------------------------------------------------
## Purpose: Creates a graphML URInode with id data and name inserted.
# Arguments:
#  @id The id of the node
#  @name The name of the node
#  @data The data to be inserted in the data field.
def createURINode(id,name,data):
    nodedef="""    <node id='"""+str(id)+"""'>
      <data key="d4"/>
      <data key="d6">"""+str(data)+"""</data>
      <data key="d7">
        <y:ShapeNode>
          <y:Geometry height="20.0" width="20.0" x="971.5427855540593" y="240.81072079483573"/>
          <y:Fill color="#FF99CC" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="3.0"/>
          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Dialog" fontSize="16" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="22.625" modelName="eight_pos" modelPosition="n" textColor="#000000" visible="true" width="110.546875" x="-45.2734375" y="-26.625">"""+name+"""</y:NodeLabel>
          <y:Shape type="ellipse"/>
        </y:ShapeNode>
      </data>
        </node>"""

    return  nodedef

#-----------------------------------------------------------------------------------
## Purpose: Creates an edge between source and target object nodes.
# Arguments:
#  @id edge id
#  @source source node
#  @target target node
#  @name Name of edge
def createObjectPropertyEdge(id,source,target,name):
    edge="""<edge id='"""+str(id)+"""' source='"""+str(source)+"""' target='"""+str(target)+"""'>
      <data key="d11">
        <y:PolyLineEdge>
          <y:Path sx="0.0" sy="0.0" tx="0.0" ty="0.0"/>
          <y:LineStyle color="#000080" type="line" width="1.0"/>
          <y:Arrows source="circle" target="delta"/>
          <y:EdgeLabel alignment="center" backgroundColor="#FFFFFF" distance="2.0" fontFamily="Dialog" fontSize="16" fontStyle="plain" hasLineColor="false" height="22.625" modelName="side_slider" preferredPlacement="anywhere" ratio="0.0" textColor="#000080" visible="true" width="255.6953125" x="-247.5477825529773" y="-32.73473205206801">"""+name+"""<y:PreferredPlacementDescriptor angle="0.0" angleOffsetOnRightSide="0" angleReference="absolute" angleRotationOnRightSide="co" distance="-1.0" frozen="true" placement="anywhere" side="anywhere" sideReference="relative_to_edge_flow"/>
          </y:EdgeLabel>
          <y:BendStyle smoothed="false"/>
        </y:PolyLineEdge>
      </data>
   </edge>"""

    return edge

#-----------------------------------------------------------------------------------
## Purpose: Creates an edge between source and target data nodes nodes.
# Arguments:
#  @id edge id
#  @source source node
#  @target target node
#  @name Name of edge
def createDataPropertyEdge(id,source,target,name):

    edge="""<edge id='"""+str(id)+"""' source='"""+str(source)+"""' target='"""+str(target)+"""'>
      <data key="d11">
        <y:PolyLineEdge>
          <y:Path sx="0.0" sy="0.0" tx="0.0" ty="0.0"/>
          <y:LineStyle color="#008000" type="dotted" width="1.0"/>
          <y:Arrows source="transparent_circle" target="white_delta"/>
          <y:EdgeLabel alignment="center" backgroundColor="#FFFFFF" distance="2.0" fontFamily="Dialog" fontSize="16" fontStyle="plain" hasLineColor="false" height="22.625" modelName="side_slider" preferredPlacement="anywhere" ratio="0.0" textColor="#008000" visible="true" width="114.21875" x="-6.203965473127596" y="10.150272623681985">"""+name+"""<y:PreferredPlacementDescriptor angle="0.0" angleOffsetOnRightSide="0" angleReference="absolute" angleRotationOnRightSide="co" distance="-1.0" frozen="true" placement="anywhere" side="anywhere" sideReference="relative_to_edge_flow"/>
          </y:EdgeLabel>
          <y:BendStyle smoothed="false"/>
        </y:PolyLineEdge>
      </data>
    </edge>"""
    return edge


    
#-----------------------------------------------------------------------------------
#                                       Node patterns
#-----------------------------------------------------------------------------------
## Purpose: Create graphML for a temporal property. This is a property with a start and
#           an end range.
# Arguments:
#  @parent
#  @propertyname
def createTemporalProperty(parent,propertyname):
#     TEMPORALENTITY NODE
    temporalentitynode=nodeid()
    print createObjectNode(temporalentitynode,"time:TemporalEntity","")
#     NODE THAT NEEDS TO POINT TO ABOVE, SO property node
    temporalproperty=nodeid()
    cv=col()+","+vis()
    print createObjectNode(temporalproperty,PREFIX_WITH_COLON+propertyname,col()+","+vis())
#     NODE WITH DATE VALUE START
    datevaluestartnode=nodeid()
    print createObjectNode(datevaluestartnode,"time:TimeInstant","")
#     NODE WITH DATE VALUE END
    datevalueendnode=nodeid()
    print createObjectNode(datevalueendnode,"time:TimeInstant","")
#     TIME INSTANT NODE
    timestartnode=nodeid()
    print createDataNode(timestartnode,"xsd:datetimestamp",col()+";0,"+vis())
#     TIME INSTANT NODE
    timeendnode=nodeid()
    print createDataNode(timeendnode,"xsd:datetimestamp",col()+";1,"+vis())
#   THE SUBCLASS Edge from museum or 
    subclassedge=edgeid()
    print createObjectPropertyEdge(subclassedge,temporalproperty,temporalentitynode,"rdfs:subClassOf")
#   INDATETIME edge to startl
    timeinstant_start_to_datetimestamp_edge=edgeid()
    print createDataPropertyEdge(timeinstant_start_to_datetimestamp_edge,
               datevaluestartnode,
               timestartnode,
               "time:inXSDDateTime")
#     INDATETIME edge to end
    timeinstant_end_to_datetimestamp_edge=edgeid()
    print createDataPropertyEdge(timeinstant_end_to_datetimestamp_edge,
               datevalueendnode,
               timeendnode,
               "time:inXSDDateTime")
#     HASBEGINNING edge
    beginningedge=edgeid()
    print createObjectPropertyEdge(beginningedge,temporalentitynode,datevaluestartnode,"time:hasBeginning")
#     HASENDEDGE
    endedge=edgeid()
    print createObjectPropertyEdge(endedge,temporalentitynode,datevalueendnode,"time:hasEnd")
#   Parent node edge
    parentedge=edgeid()
    print createObjectPropertyEdge(parentedge,parent,temporalproperty,DEFRANGE+propertyname)
    return

#-----------------------------------------------------------------------------------
## Purpose: Create graphML for an abstract RANGE_TYPE property.
# Arguments:
#  @parent parent node
#  @propertyname name of node
#  @rangetype Type of property (int,decimal or date)

def createValueRangeProperty(parent,propertyname,rangetype):
#     TEMPORALENTITY NODE
    temporalentitynode=nodeid()
    print createObjectNode(temporalentitynode,"bbkmm:ValueRange","")
#     NODE THAT NEEDS TO POINT TO ABOVE, SO property node
    temporalproperty=nodeid()
    cv=col()+","+vis()
    print createObjectNode(temporalproperty,PREFIX_WITH_COLON+propertyname,col())
#   NODE determining type of value
    datatypenode=nodeid()
    print createDataNode(datatypenode,"xsd:string","xsd:(xsd:"+rangetype+"),"+vis())
    valuerange_to_datatype_edge=edgeid()
    print createDataPropertyEdge(valuerange_to_datatype_edge,
				 temporalentitynode,
				 datatypenode,
				 "bbkmm:hasDataType")
#     NODE WITH DATE VALUE START
    datevaluestartnode=nodeid()
    print createObjectNode(datevaluestartnode,"bbkmm:LowerValue","")
#     NODE WITH DATE VALUE END
    datevalueendnode=nodeid()
    print createObjectNode(datevalueendnode,"bbkmm:UpperValue","")
#     UPPERINSTANT NODE
    timestartnode=nodeid()
    print createDataNode(timestartnode,"xsd:anyType",col()+";0,"+vis())
#     LOWER INSTANT NODE
    timeendnode=nodeid()
    print createDataNode(timeendnode,"xsd:anyType",col()+";1,"+vis())
#   THE SUBCLASS Edge from museum or 
    subclassedge=edgeid()
    print createObjectPropertyEdge(subclassedge,temporalproperty,temporalentitynode,"rdfs:subClassOf")
#   lower value edge to start
    timeinstant_start_to_datetimestamp_edge=edgeid()
    print createDataPropertyEdge(timeinstant_start_to_datetimestamp_edge,
               datevaluestartnode,
               timestartnode,
               "bbkmm:hasLowerValue")
#     upper value  edge to end
    timeinstant_end_to_datetimestamp_edge=edgeid()
    print createDataPropertyEdge(timeinstant_end_to_datetimestamp_edge,
               datevalueendnode,
               timeendnode,
               "bbkmm:hasUpperValue")
#     HASBEGINNING edge
    beginningedge=edgeid()
    print createObjectPropertyEdge(beginningedge,temporalentitynode,datevaluestartnode,"bbkmm:hasLowerRange")
#     HASENDEDGE
    endedge=edgeid()
    print createObjectPropertyEdge(endedge,temporalentitynode,datevalueendnode,"bbkmm:hasUpperRange")
#   Parent node edge
    parentedge=edgeid()
    print createObjectPropertyEdge(parentedge,parent,temporalproperty,DEFRANGE+propertyname)
    return

#-----------------------------------------------------------------------------------
## Purpose: Create graphML for a URI property that defines a name.
# Arguments:
#  @parent parent node
#  @propertyname name of property
#  @rangetype    Range of value

def createURIreferenceObjectProperty(parent,propertyname,rangetype):
#     TEMPORALENTITY NODE
    global NODEID
    NODEID=NODEID+1
    urinode=NODEID
    cv=col()+","+vis()
    print createURINode(urinode,"bbkmm:"+propertyname,col())
#   Parent node edge
    parentedge=edgeid()
    print createObjectPropertyEdge(parentedge,parent,urinode,"uri:refersTo"+propertyname)
    return

#-----------------------------------------------------------------------------------
## Purpose:
# Arguments:
#  @values
#  @level
#  @base
#  @dict
def getKey(values,level,base,dict):
    if (level == 0):
	return base
    else:
	key=""
	i=0
	while ( i < level ):
	    key=key+"/"+cleanName(str(values[i]))
	    i+=1
	return dict[key]

#-----------------------------------------------------------------------------------
## Purpose: Returns name of class for   hierarchies
# Arguments:
#  @clazzname
def getNameForClass(clazzname):
    path=clazzname.split("/")
    return str(path[len(path)-1])

#-----------------------------------------------------------------------------------
## Purpose:Creates graphML for all classes in a hierarchy by traversing all rows and
# putting each class in a dictionary.
# Arguments:
#  @parent parent node id
#  @propertyname name of hierarchy
def createHierarchySubclasses(parent,propertyname):

    global COL
    global NODEID
    global SYMBOLTABLE
    global PRINT_LINE

    ###  Go through all rows in COL and generate list of classes/subclasses
    cl=len(content)
    startrow=5
    classdict={}
    base=parent
    while (startrow < cl ):
        row=content[startrow].split(SEPARATOR)
	values=row[COL].split("/")
	del values[0]
	level=0
	key=""
	while (level < len (values)):
	    key=key+"/"+cleanName(str(values[level]))
	    if (key in classdict):
		source=classdict[key]
	    else:
		NODEID=NODEID+1
		classdict[key]=NODEID
		target=classdict[key]
		source=getKey(values,level,0,classdict)
		if (level == 0):
		    print createObjectNode(target,PREFIX_WITH_COLON+getNameForClass(key),key)
		    subclassedge=edgeid()
		    print createObjectPropertyEdge(subclassedge,target,base,"rdfs:subClassOf")
		else:
		    print createObjectNode(target,PREFIX_WITH_COLON+getNameForClass(key),key)
		    subclassedge=edgeid()
		    print createObjectPropertyEdge(subclassedge,target,source,"rdfs:subClassOf")
	    level+=1
	    
        startrow+=1
	
    return

#-----------------------------------------------------------------------------------
# MAIN STARTING
#-----------------------------------------------------------------------------------

## Deal with all arguments; read files.
sequenceorder=0
fname=str(sys.argv[2])
tname=str(sys.argv[3])

with open(fname) as f:
	content = f.readlines()
f.close()
headerline=content[0]
header=headerline.split(SEPARATOR)
for h in header:
    h=h.strip().replace('\n', '').replace('\r', '')
with open(tname) as f:
	template = f.readlines()
f.close()

## Process the dataproperty.template file ###

SYMBOLTABLE={}
SYMBOLTABLE[SEQUENCE_ORDER]=0
PRINT_LINE=True

i = 0
datamodel=content[1].split(SEPARATOR)
for d in datamodel:
    d=d.strip().replace('\n', '').replace('\r', '')
visdatamodel=content[3].split(SEPARATOR)

##Get rid of any newlines in last field
vcount=0
for vv in visdatamodel:
    visdatamodel[vcount]=vv.strip()
    vcount=vcount+1
    

valuedatamodel=content[2].split(SEPARATOR)

SYMBOLTABLE[SEQUENCE_ORDER]=0
SYMBOLTABLE[BASE_NODE]="n0" # Museum

while i < len(datamodel):
    COL=i
    SYMBOLTABLE[PROCESSINGCOLUMN]=COL
    processTemplate(header,template,datamodel,SYMBOLTABLE)
    i += 1

## Process the objectproperty.template file ###
tname=str(sys.argv[4])
PRINT_LINE=False

with open(tname) as f:
	template = f.readlines()
f.close()
i = 0

while i < len(datamodel):
    COL=i
    SYMBOLTABLE[PROCESSINGCOLUMN]=COL
    processTemplate(header,template,datamodel,SYMBOLTABLE)
    i += 1
    
